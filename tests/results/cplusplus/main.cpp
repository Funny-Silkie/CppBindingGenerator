#include <iostream>
#include <memory>
#include <string>
#include <algorithm>

#ifdef WIN32
#include <Windows.h>
#include <direct.h>
#else
#include <sys/types.h>
#include <unistd.h>
#endif

#if defined(__APPLE__)
#include <mach-o/dyld.h>
#endif

#include "AutoGeneratedCoreBindings.h"

#undef max
#undef min

std::string GetDirectoryName(const std::string& path)
{
	const std::string::size_type pos = std::max<int32_t>(path.find_last_of('/'), path.find_last_of('\\'));
	return (pos == std::string::npos) ? std::string() : path.substr(0, pos + 1);
}

std::string GetExecutingDirectory()
{
	char buf[260];

#ifdef _WIN32
	int len = GetModuleFileNameA(NULL, buf, 260);
	if (len <= 0)
		return "";
#elif defined(__APPLE__)
	uint32_t size = 260;
	if (_NSGetExecutablePath(buf, &size) != 0)
	{
		buf[0] = 0;
	}
#else

	char temp[32];
	sprintf(temp, "/proc/%d/exe", getpid());
	int bytes = std::min((int)readlink(temp, buf, 260), 260 - 1);
	if (bytes >= 0)
		buf[bytes] = '\0';
#endif

	return GetDirectoryName(buf);
}

void SetCurrentDir(const char* path)
{
#ifdef _WIN32
	_chdir(path);
#else
	chdir(path);
#endif
}

int main()
{
    //SetCurrentDir(GetExecutingDirectory().c_str());
    //if(!HelloWorldA::LoadLibrary())
    //{
    //    std::cout << "Failed to load library." << std::endl;
    //    return 1;
    //}

    auto a = std::shared_ptr<HelloWorldA::ClassA>(new HelloWorldA::ClassA());
    a->FuncSimple();
    a->FuncArgInt(2);
    a->FuncArgFloatBoolStr(2.2f, true, u"hello");

    if(HelloWorldA::ClassA::FuncReturnStatic() != 1)
        throw "Process call failed : HelloWorld::ClassA::FuncReturnStatic()";

    a->set_EnumA(HelloWorldA::Animal::Tiger);
    if(a->get_EnumA() != HelloWorldA::Animal::Tiger)
        throw "Process call failed : HelloWorld::ClassA::get_EnumA()";

    HelloWorldA::StructA_C *sa = new HelloWorldA::StructA_C();
    sa->X = 1.0f;
    sa->Y = 2.0f;
    sa->Z = 3.0f;
    a->FuncArgStruct(std::shared_ptr<HelloWorldA::StructA_C>(sa));

    auto cb = std::shared_ptr<HelloWorldA::ClassB>(new HelloWorldA::ClassB());
    cb->SetValue(100);
    a->FuncArgClass(cb);

    auto retBool = a->FuncReturnBool();
    std::cout << "retBool:" << (retBool ? "true" : "false") << std::endl;

    auto retStruct = a->FuncReturnStruct();
    std::cout << "retStruct(should 2, 1, 3):"
        << retStruct.X << ", " << retStruct.Y << ", " << retStruct.Z << std::endl;

    auto retString = a->FuncReturnString();
    std::cout << retString.c_str() << std::endl;

    auto retClass = a->FuncReturnClass();
    retClass->SetValue(101);
    a->FuncArgClass(retClass);

    std::cout << "Inheritance Test:" << std::endl;
    auto derived = std::shared_ptr<HelloWorldA::DerivedClass>(new HelloWorldA::DerivedClass());
    auto asBase = std::static_pointer_cast<HelloWorldA::BaseClass>(derived);
    asBase->SetBaseClassField(12345);
    std::cout << "As Base Value:" << asBase->GetBaseClassField() << std::endl;
    std::cout << "Derived Value:" << derived->GetBaseClassFieldFromDerivedClass() << std::endl;
	
    return 0;
}